-----
### Keep-Alive 커넥션 제한과 규칙
-----
1. Keep-Alive는 HTTP/1.0에서 기본으로 사용되지 않음
   - 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection: Keep-Alive 요청 헤더를 보내야 함

2. 커넥션을 계속 유지하려면 모든 메세지에 Connection: Keep-Alive 헤더를 포함해 보내야 함
   - 만약 클라이언트가 Connection: Keep-Alive 헤더를 보내지 않으면, 서버는 요청을 처리한 후 커넥션을 끊을 것

3. 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후 커넥션을 끊을 것임을 알 수 있음
4. 커넥션이 끊어지기 전 엔티티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있음
   - 즉, 엔티티 본문이 정확한 Content-Length 값과 함꼐 멀티파트 형식(Multi-Part Media Type)을 가지거나 청크 전송 인코딩(Chunked Transfer Encoding)으로 인코딩 되어야 함을 뜻함
   - keep-alive 커넥션에서 잘못된 Content-Length 값을 보내는 것은 좋지 않은데, 트랜잭션이 끝나는 시점에 기존 메세지의 끝과 새로운 메세지 시작점을 정확히 알 수 없기 때문임

5. 프록시와 게이트웨이는 Connection 헤더 규칙을 철저히 지켜야 함
   - 프록시와 게이트웨이는 메세지를 전달하거나 캐시에 넣기 전 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 함

6. 정석대로라면, Keep-Alive 커넥션은 Connection 헤더를 인식하지 못하는 프록시 서버와는 맺어지면 안 됨
   - 이는 멍청한(Dumb) 프록시로 인해 발생할 문제를 예방하기 위한 것이지만, 현실적으로는 쉽지 않음

7. 기술적으로 HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드(Connection: Keep-Alive 포함)는 무시해야 함
   - 오래된 프록시 서버로부터 실수로 전달될 수 있기 떄문이며, 실제로 어떤 클라이언트나 서버는 오래된 프록시에 행(Hang)을 걸릴 수 있는 위험이 있음에도 이 규칙을 지키지 않아도 됨

8. 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어야 있어야 하며, 그렇지 않으면 요청이 반복될 경우 문제가 발생할 수 있음
