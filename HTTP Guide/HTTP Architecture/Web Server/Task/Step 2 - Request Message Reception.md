-----
### 단계 2 : 요청 메세지 수신
-----
1. 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메세지 구성
<div align="center">
<img src="https://github.com/user-attachments/assets/eac85e7e-3eeb-46ee-8a69-883aaa788ffc">
</div>

2. 요청 메세지를 파싱할 때, 웹 서버가 하는 역할
   - 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호(HTTP 초기 버전인 HTTP/0.9는 버전 번호를 지원하지 않음)를 찾고, 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF, LF) 문자열로 끝남
   - 메세지 헤더들을 읽으며, 각 메세지 헤더는 CRLF로 끝남
   - 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아냄 (존재한다면)
   - 요청 본문이 있다면, 읽어들임 (길이는 Content-Length 헤더로 정의)

3. 메세지의 내부 표현
   - 몇몇 웹 서버는 요청 메세지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장
   - 예를 들어, 그 자료 구조는 요청 메세지의 각 조각에 대한 포인터와 길이를 담을 수 있을 것이고, 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근할 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/ad694de0-fcdc-4222-8624-728da1d39802">
</div>

4. 커넥션 입력 / 출력 처리 아키텍쳐
   - 고성능 웹 서버는 수 천개의 커넥션을 동시에 열 수 있도록 지원
   - 이 커넥션은 웹 서버가 전 세계의 클라이언트들과 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 해줌
   - 이런 커넥션들로부터 요청이 느리게 혹은 드물게 흘러 들어오고, 또 어떤 것들은 나중에 일어날 활동을 위해 조용히 대기하고 있는데 비해, 일부 커넥션들은 웹 서버로 급속히 요청을 보내고 있을 것
   - 웹 서버들은 항상 새 요청을 주시하고 있음 : 요청은 언제라도 도착할 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/c464b9b4-a3ba-47dd-9f0e-0bf2adf969f5">
</div>

   - 웹 서버 아키텍쳐 차이에 따른 요청 처리 방식
     + 단일 스레드 웹 서버 (5-7a) : 한 번에 하나의 요청을 처리하며, 트랜잭션이 완료되면 다음 커넥션을 처리
       * 간단하지만, 처리 도중 다른 커넥션은 모시되며, 이는 심각한 성능 문제를 만들어내므로 오직 로드가 적은 서버나 진단 도구에서만 사용 가능

     + 멀티프로세스와 멀티스레드 웹 서버 (5-7b) : 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당 (프로세스 : 어던 프로그램 자신만의 변수 집합을 갖는 하나의 독립된 제어 흐름이며, 스레드는 더 빠르고 더 효율적인 버전으로, 두 개 모두 하나의 프로그램이 여러 작업을 동시에할 수 있게 해줌)
       * 스레드 / 프로세스는 필요할 떄 마다 만들어질 수 있고, 미리 만들어질 수 있음 (스레드가 미리 생성되는 시스템을 스레드 풀(Thread Pool) 시스템)
       * 몇 서버는 매 커넥션마다 스레드 / 프로세스 하나를 할당하지만, 서버가 수백 ~ 수만 개의 동시 커넥션이 처리할 떄 그로 인해 만들어진 수많은 프로세스나 스레드는 너무 많은 메모리나 시스템 리소슬르 소비하므로, 많은 멀티스레드 웹 서비스가 스레드 / 프로세스의 최대 개수 제한을 둠

     + 다중 I/O 서버 (5-7c) : 대량의 커넥션을 지원하기 위해, 많은 웹 서버는 다중 아키텍쳐를 채택
       * 다중 아키텍쳐에서는, 모든 커넥션은 동시에 그 활동을 감시당하며, 커넥션의 상태가 바뀌면(예) 데이터를 사용할 수 있게 되거나 에러가 발생), 그 커넥션에 대해 작은 양의 처리가 수행
       * 그 처리가 완료되면, 커넥션은 다음 번 상태 변경을 위해 열린 커넥션 몰록으로 돌아감
       * 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 해야 할 일이 있을 때 뿐이며, 스레드와 프로세스는 유휴 상태의 커넥션에 매여 기다리느라 리소스를 낭비하지 않음

     + 다중 멀티스레드 웹 서버 (5-7d) : 몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 다중화(Multiplexing)를 결합
       * 여러 개의 스레드(보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션(혹은 열려있는 커넥션의 부분 집합)을 감시하고, 각 커넥션에 대해 조금씩 작업 수행
