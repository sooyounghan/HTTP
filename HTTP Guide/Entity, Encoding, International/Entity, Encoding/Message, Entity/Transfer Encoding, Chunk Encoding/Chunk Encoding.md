-----
### 청크 인코딩
-----
1. 청크 인코딩은 메세지를 일정 크기의 청크 여럿으로 쪼갬
2. 서버는 각 청크를 순차적으로 보내며, 청크 인코딩을 이용하면 메세지를 보내기 전 전체 크기를 알 필요가 없어짐
3. 본문이 동적으로 생성됨에 따라, 서버는 그 중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함께 보낼 수 있으며, 본문 전체를 모두 보낼 때까지 이 단계 반복
4. 청크 인코딩은 전송 인코딩의 한 형태이며, 본문이 아닌 메세지의 속성

5. 청크와 지속 커넥션
   - 클라이언트와 서버 사이 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없음
   - 클라이언트는 서버가 커넥션을 닫을 때까지 본문으로 간주하고 읽을 것
   - 지속 커넥션에서는, 본문을 쓰기 전 반드시 Content-Length 헤더에 본문의 길이를 담아 보내줘야 함
   - 서버가 동적으로 생성되는 경우, 보내기 전 본문의 길이를 알아내는 것이 불가능할 것
   - 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로 해법을 제공하며, 동적으로 본문이 생성되면서, 서버는 그 중 일부를 버퍼에 담은 뒤 그 한 덩어리를 그의 크기와 함께 보낼 수 있으며, 본문을 모두 보낼 때까지 이 단계를 반복
   - 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있음

6. 청크 인코딩의 기본 구조
<div align="center">
<img src="https://github.com/user-attachments/assets/61d09b38-64d9-4143-99ba-b1e594ffc6b6">
</div>

   - HTTP 응답 헤더 블록으로 시작하고, 이어서 청크 스트림이 옴
   - 각 청크는 길이 값과 각 청크에 대한 데이터를 담고 있음
   - 길이 값은 16진수 형식으로 되어 있고, 청크 데이터와 CRLF로 분리
   - 청크 데이터 길이는 바이트 단위로 측정되고, 청크 끝의 CRLF 문자열 뿐만 아니라 길이 값과 데이터 사이 CRLF 문자열도 길이에 포함되지 않음
   - 마지막 청크는 본문의 끝을 의미하므로 길이가 0
   - 클라이언트는 또한 청크 인코딩된 데이터를 서버로 전송
   - 클라이언트는 서버가 청크 인코딩을 받아들여줄지 모르므로(서버는 클라이언트에게 응답에 TE 헤더를 포함시켜 보내지 않음), 청크 요청이 411 Length Required 응답으로 거절 당하는 것에 대비해야 함

7. 청크 인코딩 된 메세지의 트레일러 : 다음 중 하나 이상의 조건을 만족하면 청크 메세지에 트레일러 추가 가능
   - 클라이언트가 TE 헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
   - 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러의 콘텐츠는 클라이언트가 이해하고, 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
   - 트레일러는 본문의 콘텐츠가 먼저 생성되어야 한다거나 등의 이유로 메세지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있음
   - 트레일러로 보낼 수 있는 헤더의 예로 Content-MD5 헤더가 있음 (문서가 생성되기 전 그 문서의 MD5를 계산하기는 어려움)
   - 메세지 헤더는 청크 인코딩 된 메세지 다음에 오게 될 헤더를 나열하는 Trailer 헤더 포함
   - 마지막 청크 다음 Trailer 헤더에 나열했던 헤더들이 옴
   - Transfer-Encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러를 보낼 수 있음
