-----
### 프락시 요청 특징
-----
1. 프락시 URI는 서버 URI과 다름
   - 웹 서버와 웹 프록시 메세지 문법은 서로 같지만, 한 가지 예외 존재 : 클라이언트가 프록시 대신 서버로 요청을 보내면 요청의 URI가 달라짐
   - 클라이언트가 웹 서버로 요청을 보낼 때, 요청줄은 다음과 같이 스킴, 호스트, 포트번호가 없는 부분 URI를 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/4b8d10da-0b22-479a-9e91-2390a6e58579">
</div>

2. 그러나 클라이언트로 프록시로 요청을 보낼 때, 요청줄은 다음의 예와 같이 완전한 URI를 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/093da9e8-041f-43cf-af4e-8006b35b4a87">
</div>

3. 다른 요청 형식을 갖는 이유
   - 원래의 HTTP 설계에서, 클라이언트는 단일 서버와 직접 대화했음
   - 가상 호스팅은 아직 존재하지 않았고, 프록시에 대한 대비도 없었음
   - 단일 서버는 자신의 호스트 명과 포트번호를 알고 있으므로, 클라이언트는 불필요한 정보 발송을 피하기 위해 스킴과 호스트(그리고 포트번호)가 없는 부분 URI만 보냈음
   - 프록시가 부상하면서, 부분 URI는 문제가 되었음
     + 프록시는 목적지 서버와 커넥션을 맺어야 하므로, 그 서버의 이름을 알 필요가 있음
     + 그리고 프록시 기반 게이트웨이는 FTP 리소스나 혹은 그 외의 스킴과 연결하기 위해 URI 스킴을 알 필요가 있었음
     + HTTP/1.0은 프록시 요청의 경우 완전한 URI를 요구하는 것으로 이 문제를 해결했지만, 서버 요청 부분 URI은 여전히 문제 (모두 완전한 URI로 전환하기에 너무 많은 서버가 배치)
     + 따라서 프락시와 서버 요청 모두에 대해 HTTP/1.1은 현재 서버들이 완전한 URI를 다룰 것을 요구하지만, 현실에는 배치 되어 있는 서버들 중 다수가 여전히 부분 URI만을 받아들임

   - 따라서, 서버로는 부분 URI를, 프록시로는 완전한 URI를 보낼 필요가 있으며, 명시적으로 설정된 클라이언트 프록시 설정의 경우, 클라이언트는 어떻게 요청을 보내야 하는지 알고 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/3953e66a-7832-4c51-89ad-0cdfcdd7036e">
</div>

   - 클라이언트가 프록시를 사용하지 않도록 설정되었다면, 부분 URI를 보냄 (6-15a)
   - 클라이언트가 프록시를 사용하도록 설정되었다면, 완전한 URI를 보냄 (6-15b)

4. 가상 호스팅에서 일어나는 같은 문제
   - 프록시의 스킴/호스트/포트번호 누락 문제는 가상으로 호스팅되는 웹 서버가 직면한 것과 같은 문제
   - 가상으로 호스팅되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유
   - 요청 하나가 부분 URI /index.html로 오면, 가상으로 호스팅 되는 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 있음
   - 해결 방법
     + 명시적인 프록시는 요청 메세지가 완전한 URI를 갖도록 문제 해결
     + 가상으로 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨있는 Host 헤더 요구

5. 인터셉트 프록시는 부분 URI를 받음
   - 클라이언트가 HTTP를 올바르게 구현했다면, 그들은 명시적으로 설정된 프록시에게는 완전한 URI를 보낼 것
   - 문제의 일부분은 해결되지만, 클라이언트는 자신이 프록시와 대화하고 있음을 항상 알고 있지 않음
     + 왜냐하면 몇 프록시는 클라이언트에게는 보이지 않을 수 있기 때문임
     + 비록, 클라이언트가 프록시를 사용한다고 설정되어 있지 않더라도, 클라이언트 트래픽은 여전히 대리 프록시나 인터셉트 프록시를 지날 수 있음
     + 두 가지 경우 모두, 클라이언트는 자신의 웹 서버와 대화하고 있다고 생각하고 완전한 URI를 보내지 않을 것

    - 대리 프록시는 원 서버와 호스트 명과 아이피 주소를 원 서버를 대신하는 프록시 서버
    - 인터셉트 프록시는 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽은 가로채 캐시된 응답을 돌려주는 등의 일을 하는 프록시 서버로, 클라이언트에서 서버로 가는 트래픽을 가로채기 때문에, 웹 서버로 보내는 부분 URI를 얻게 될 것 (인터셉트 프록시는 보통 80번 포트만 가로챔)

6. 프록시는 프록시 요청과 서버 요청 모두 다룰 수 있음
   - 트래픽이 프록시 서버로 리다이렉트 될 수 있는 여러 가지 방법 존재
   - 다목적 프록시 서버는 요청 메시지의 완전한 URI 부분과 부분 URI를 모두 지원해야 함
   - 프록시는 명시적인 프록시 요청에 대해서는 완전한 URI를 사용하고 아니면 부분 URI를 사용해야 하며, 웹 서버 요청의 경우에는 가상 Host 헤더를 사용
   - 완전 URI과 부분 URI를 사용하는 규칙
     + 완전한 URI가 주어진다면, 프록시는 이를 사용해야 함
     + 부분 URI가 주어졌고, Host 헤더가 있다면, Host 헤더를 이용해 원 서버 이름과 포트 번호를 알아내야함
     + 부분 URI이 주어졌으나, Host 헤더가 없다면, 다음 방법으로 원 서버를 알아냄
       * 프록시가 원 서버를 대신하는 대리 프록시라면, 프록시에 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있음
       * 이전에 어떤 인터셉트 프록시가 가로챘던 트래픽을 받았고, 그 인터셉트 프록시가 원 IP 주소와 포트번호를 사용할 수 있도록 해뒀다면, 그 IP 주소와 포트 번호를 사용할 수 있음
       * 모두 실패했다면, 프록시는 원 서버를 알아낼 수 있는 충분한 정보를 갖지 못한 것이므로 반드시 에러 메세지(보통 사용자에게 Host 헤더를 지원하는 현대적 웹브라우저로 업그레이드)를 반환

7. 전송 중 URI 변경
   - 프록시 서버는 요청 URI 변경에 매우 신경을 써야함
   - 무해해 보이는 사소한 URI 변경이더라도 다운 스트림 서버와 상호 운용성 문제 발생 가능
   - 특히 몇몇 프록시는 URI를 다음 홉으로 보내기 전 표준 형식으로 정규화하는 것으로 알려져 있음
     + URI에서 기본 HTTP 포트를 명시적인 :80으로 변경하는 것이나 잘못 사용한 예약된 글자를 올바르게 이스케이프하여 교체하는 것과 같은 무해해 보이는 변형이라 할지라도, 상호운용성 문제를 일으킬 수 있음
   - 일반적으로 프록시 서버는 가능한 한 관대하도록 애써야 함
   - HTTP 명세는 일반적인 인터셉트 프록시가 URI를 전달할 때, 절대 경로를 고쳐 쓰는 것을 금지하며, 유일한 예외는 빈 경로를 '/'로 교체하는 것

8. URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)
   - 브라우저는 프록시 존재 여부에 따라 요청 URI를 다르게 분석
   - 프록시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP 주소를 찾음
   - 만약 호스트 명이 발견되면 그에 대응하는 IP 주소들을 연결에 성공할 때까지 시도
   - 그러나 호스트가 발견되지 않는다면, 많은 브라우저들은 사용자가 호스트 명의 짧은 약어를 타이핑 한 것으로 보고 자동화된 호스트 명의 확장을 제공하고자 다음과 같은 몇 가지 시도 실시
     + 일반적인 웹 사이트 이름의 가운데 부분만 입력했다면, 많은 브라우저는 ```www.``` 접두사를 붙이고, ```.com``` 접미사를 붙임
     + 몇몇 브라우저는 해석할 수 없는 URI를 서드파티 사이트로 넘기도록 하는데, 이 사이트는 오타 교정을 시도하고 사용자가 의도했을 URI 제시
     + 대부분의 시스템에서 DNS는 사용자가 호스트 명 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정
       * 예를 들어, ```oreilly.com```이라는 도메인에 있을 때, host7을 입력한다면, 그 도메인의 DNS는 자동으로 ```host.oreilly.com```을 찾아봄 (이는 완전하지도, 유효하지도 않은 호스트명)

9. 프록시 없는 URI 분석 (URI Resolution)
<div align="center">
<img src="https://github.com/user-attachments/assets/c73bda00-04e1-40cf-bb60-ad2557c33af2">
</div>

   - 프록시 없는 브라우저 호스트 명 자동확장의 예
   - 2a ~ 3c까지의 단계 : 브라우저는 유효한 호스트명이 발견될 떄까지 다양한 호스트 명의 가능성들을 검색
     + 단계 1 : 사용자는 oreilly를 브라웢 URI 창에 입력 - 브라우저는 oreilly를 호스트 명으로 사용하고 기본 스킵을 ```http://```로, 기본 포트를 80으로, 기본 경로를 /로 간주
     + 단계 2a, 2b : 브라우저는 호스트 oreilly를 찾아보지만 실패
     + 단계 3a, 3b, 3c : 브라우저는 호스트 명을 자동으로 확장한 후 DNS에 ```www.oreilly.com```의 주소 분해를 요청하고, 이는 성공
     + 브라우저는 ```www.oreilly.com``` 연결 성공

10. 명시적인 프록시를 사용할 때의 URI 분석
    - 명시적인 프록시를 사용한다면, 브라우저는 편리한 확장들 중 어느 것도 수행할 수 없음 : 브라우저의 URI는 프록시를 그냥 지나쳐버리기 떄문임
    - 브라우저는 명시적 프록시가 있을 경우 부분 호스트 명을 자동확장 하지 않음
<div align="center">
<img src="https://github.com/user-attachments/assets/48a51040-465c-4157-9dd5-3bd23e0c0291">
</div>

   - 그 결과, 사용자의 브라우저 위치 창에 oreilly를 타이핑했을 떄, 프록시는 ```http://oreilly/```라고 보냄 (브라우저는 기본 스킵과 경로를 추가하지만, 호스트 명은 입력한 대로 남겨둠)
   - 이러한 이유로 몇 프록시는 ```www...com``` 자동확장이나 지역 도메인 접미사 추가와 같은 브라우저의 편리한 서비스를 할 수 있다면 최대한 흉내 내려고 시도하지만, 프록시들은 광범위하게 공유되므로 개개인들 각각에게 알맞은 도메인 접미사를 알아내는 것은 불가능할 것

11. 인터셉트 프록시를 이용한 URI 분석
    - 호스트 명 분석은 보이지 않는 인터셉트 프록시와 함께 사용할 때, 클라이언트의 입장에서 프록시는 존재하는 것이므로 문제가 발생
    - DNS가 성공할 때까지 호스트 명을 자동확장 할 때, 동작은 프록시가 아닌 서버의 경우와 별 차이가 없음
    - 하지만, 서버로의 커넥션이 만들어졌을 때 차이 발생
    - 트랜잭션 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/c6d5e58a-c975-4ea4-bf16-22991dd8536d">
</div>

   - 단계 1 : 사용자는 브라우저의 URI 창에 oreilly라고 타이핑
   - 단계 2a : 브라우저는 호스트 oreilly를 DNS를 통해 찾아보지만, 단계 2b에서 DNS 서버는 실패하고 그 호스트는 알 수 없다고 응답
   - 단계 3a : 브라우저는 oreilly를 ```www.oreilly.com```으로 변환하는 자동 확장 실시
   - 단계 3b : 브라우저는 DNS를 통해 호스트 ```www.oreilly.com```을 찾아봄
   - 단계 3c : DNS 서버는 성공하고 IP 주소를 브라우저거 반환
   - 단계 4a : 클라이언트는 이미 성공적으로 호스트 명을 분석하였고, IP 주소의 목록을 가지고 있음
     + 일반적으로 클라이언트는 성공할 때까지 모든 IP 주소에 대해 접속을 시도하지만, 어떤 IP들은 죽은 것일 수 있음
     + 그러나 인터셉트 프록시와 함께라면, 첫 번째 접속 시도는 원 서버가 아닌 프록시 서버에 의해 종료
     + 클라이언트는 성공적으로 웹 서버와 대화했다고 믿지만, 웹 서버는 아직 살아있지도 않았을 것임
   - 단계 5b : 프록시가 최종적으로 진짜 원 서버와 상호작용할 준비가 되었을 때, 프록시는 그 IP 주소가 실제로 다운된 서버를 가리키고 있음을 알게 됨
     + 브라우저에게 제공하는 것과 동등한 수준의 장애 허용(Fault Tolerance)를 제공하기 위해, 프록시는 호스트 헤더에 들어 있는 호스트 명을 다시 분석하든, 아니면 IP 주소에 대한 역방향 DNS 룩업을 해서든 다른 IP 주소를 시도해야 함
     + 인터셉트 프록시와 명시적인 프록시 모두 죽은 서버의 DNS 분석에 대한 장애 허용을 지원해야 하는 것이 중요 : 브라우저가 명시적인 프록시를 사용하도록 설정되어 있는 경우 허용은 프록시에 달려있기 때문임
