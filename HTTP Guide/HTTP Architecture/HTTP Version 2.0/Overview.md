-----
### HTTP/2.0 등장 배경
-----
1. HTTP/1.1 메세지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화
   - 따라서 성능은 어느정도 떨어질 수 밖에 없음 : 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP 메세지 교환 방식은 단순함 면에서 더할 나위 없었지만, 응답을 받아야만 그 다음 요청을 보낼 수 있으므로 심각한 회전 지연(Latency)를 피할 수 없었음
   - 이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입됐지만, 성능 개선에 근본적 해결책이 되지 못함

2. HTTP/1.1 명세 발표 이후, 이 성능 문제 해결을 위해 많은 노력 실시
   - HTTP 작업 그룹은 HTTP/1.1 발표되기도 전인 1997년 7월 HTTP-NG 프로젝트 시작
   - HTTP/1.1 저자 중 한 명인 로이 필딩(Roy Fielding)은 WAKA라는 프로토콜 제안
   - 또 마이크로소프트는 Microsoft S+M(Speed+Mobility)라는 프로토콜 개발

3. 2009년, 구글은 웹을 더 빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓음
   - 기존의 HTTP 속도를 개선하기 위한 여러 기능 추가
   - 헤더를 압축하여 대역폭 절약 및 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능 갖춤
   - 12.34%의 성능 개선 효과, 80ms인 상황에서는 23.85%, 200ms 상황에서는 26.79% 성능 개선 효과

4. 2012년 10월 3일, HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정하여 HTTP/2.0 초안을 만듬
5. 2013년 11월, HTTP/2.0은 8번쨰 초안까지 나왔으며, SPDY 특징들을 그대로 유지
   - 변경된 점이라면, 헤더를 압축할 때 더이상 deflate 알고리즘을 사용하지 않음

-----
### 개요
-----
1. HTTP/2.0는 서버와 클라이언트 사이 TCP 커넥션 위에서 동작하는데, 이 때, TCP 커넥션을 초기화하는 것은 클라이언트
2. HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담기고, 이 때 HTTP 헤더는 압축되어 담김
3. 프레임들에 담긴 요청과 응답은 스트림을 통해 보내짐
   - 한 개의 스트림이 한 쌍의 요청과 응답을 처리
   - 하나의 커넥션 위에 여러 개 스트림이 동시에 만들어질 수 있으므로, 여러 개의 요청과 응답 동시 처리 가능
   - HTTP/2.0은 이들 스트림에 대한 흐름 제어와 우선순위 부여 가능

4. 기존 요청-응답과 다르게 새로운 상호작용 모델인 서버 푸시를 도입
   - 이를 통해 서버는 클라이언트에게 필요하다고 생각하는 리소스라면, 그에 대한 요청을 명시적으로 받지 않더라도 클라이언트에게 보내줄 수 있음

5. 기존 웹 애플리케이션들과 호환성 최대 유지를 위해, HTTP/2.0은 요청과 응답 메세지 의미를 HTTP/1.1과 같도록 유지
   - Content-Length 헤더는 본문 길이, 404 Not Found 응답은 리소스 찾을 수 없음을 의미하는 것과 같음
   - 다만 이를 표현하는 문법이 변경 : Content-Length는 :content-length, 상태 줄을 표현하는 404 Not Found는 404 값을 갖고 있는 :status 헤더로 표현
