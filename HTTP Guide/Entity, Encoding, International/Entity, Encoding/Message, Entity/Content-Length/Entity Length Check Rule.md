-----
### 엔티티 본문 길이 판별을 위한 규칙
-----
1. 엔티티 본문의 길이와 끝나는 위치를 바르게 판별하는 상황별 규칙으로, 규칙들은 반드시 다음에 나열된 순서대로 적용되어야 함
2. 본문을 갖는 것이 허용되지 않는 특정 타입 HTTP 메세지는, 본문 계산을 위한 Content-Length 헤더가 무시
   - 이 경우, Content-Length 헤더는 부가 정보에 불과하며, 실제 본문 길이를 서술하지 않음
   - 가장 중요한 예는 HEAD 응답으로, HEAD 메서드는 GET 요청을 보냈다면 받게 될 응답에서 본문을 제외하고 헤더들만 보내라고 서버에게 요청
     + GET 응답은 Content-Length 헤더를 돌려주므로, HEAD 응답 또한 그럴 것
     + 그러나 GET 응답과 달리 HEAD 응답은 본문을 갖지 않음
   - 1XX, 204, 304 응답 또한 정보성 Content-Length 헤더를 갖지만, 본문을 갖지 않음
   - 엔티티 본문을 금하는 메세지는 어떤 엔티티 헤더 필드가 존재하느냐에 상관없이 반드시 헤더 이후 첫 번째 빈 줄에서 끝나야 함

3. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면(기본 HTTP identity 인코딩과 다름), 메세지 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔티티 0바이트 청크라 불리는 특별 패턴으로 끝나야 함
4. 메세지가 Content-Length 헤더를 갖는다면(그리고 메세지 유형이 엔티티 본문을 허용한닫면), Transfer-Encoding 헤더가 존재하지 않는 이상, Content-Length 값은 본문 길이를 저장
   - 만약, Content-Length 헤더 필드와 identity가 아닌 Transfer-Encoding 헤더 필드를 갖고 있는 메세지를 받았다면 반드시 Content-Length 헤더 무시
   - 전송 인코딩은 엔티티 본문을 표현하고 전송하는 방식(전송된 바이트 크기도)을 바꿀 것이기 때문임

5. 메세지가 multipart/byteranges 미디어 타입을 사용하고 엔티티 길이가 별도로 정의되지 않았다면(Content-Length 헤더로), 멀티파트 메세지의 각 부분은 각자가 스스로 크기 정의
   - 이 멀티파트 유형은 자신의 크기를 스스로 결정할 수 있는 유일한 엔티티 본문 유형
   - 따라서, 이 미디어 타입은, 수신자가 이것을 해석할 수 있다는 사실을 송신자가 알기 전까지 절대 보내지 않아야 함
   - Range 헤더는 multipart/byteranges를 이해하지 못하는 더 원시적 프록시로 전달되었을 수 있으므로, 스스로 범위를 정하는(Self-Delimiting) 포맷을 수신자가 이해하는지 발송자가 확신할 수 없다면 메세지 범위를 정해야함

6. 위의 어떤 규칙에도 해당되지 않는다면, 엔티티는 커넥션이 닫힐 떄 끝남
   - 실질적으로, 오직 서버만이 메세지가 끝났음을 알리기 위해 커넥션을 닫을 수 있음
   - 클라이언트는 클라이언트가 메세지가 끝났다는 신호를 위해 커넥션을 닫을 수 없음
   - 그렇게 커넥션을 닫아버리면 서버가 응답을 돌려줄 방법이 없음 (물론, 출력 연결값만 닫는 절반 끊기(Half Close)를 할 수 있지만, 많은 서버 애플리케이션들이 이러한 상황을 다룰 수 있도록 설계 되지 않으며, 그런 서버들은 클라이언트가 서버로부터 연결을 끊은 것으로 해석할 것)

7. HTTP/1.0 애플리케이션 호환을 위해, 엔티티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 함 (서버가 HTTP/1.1과 호환된다고 알려져 있지 않다면)
   - HTTP/1.1 명세는 요청에 본문은 있지만 Content-Length 헤더는 없는 경우, 메세지 길이를 판별할 수 없다면 400 Bad Request 응답
   - 유효한 Content-Length를 요구하고 싶다면 411 Length Required 응답을 보내라고 조언
