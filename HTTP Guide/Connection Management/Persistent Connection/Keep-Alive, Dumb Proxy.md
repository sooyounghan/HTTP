-----
### Keep-Alive와 멍청한(Dumb) 프록시
-----
1. 웹 클라이언트 요청에서 Connection: Keep-Alive 헤더가 있으면, 클라이언트가 현재 연결하고 있는 TCP 커넥션을 끊지 않고 계속 유지하려는 것 (헤더 이름이 connection인 이유)
2. 클라이언트가 웹 서버에 요청을 보내려는 중이라면, 그 요청으로 생긴 커넥션이 keep-alive가 되기를 원한다는 의미로 Connection: Keep-Alive 헤더를 전송하며, 서버가 keep-alive를 지원한다면 Connection: Keep-Alive를 응답해 포함할 것이며, 지원하지 않으면 포함하지 않을 것
3. Connection 헤더의 무조건 전달
   - 프록시는 Conneciton 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고, 요청 그대로 다음 프록시에 전달
   - 오래되고 단순한 수 많은 프록시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달

4. 웹 클라이언트가 무조건 전달을 하는 멍청한 프록시를 거쳐 웹 서버에서 메세지를 전달하는 상황
<div align="center">
<img src="https://github.com/user-attachments/assets/693472aa-3136-408f-b8a6-62ddb3039f2b">
</div>

  - 4-15a : 웹 클라이언트는 프록시에 Connection: Keep-Alive 헤더와 함께 메세지를 보내고, 커넥션을 유지하기를 요청하며, 클라이언트는 커넥션을 유지하자는 요청을 받아들였는지 확인하기 위해 응답을 기다림
  - 멍청한 프록시는 요청받은 HTTP의 Connection 헤더(단순히 확장 헤더로만 취급)를 이해하지 못하며, 프록시는 keep-alive가 무엇인지 모르므로, 다음 서버에 메세지를 그대로 전달 (4-15b)
    + 하지만, Connection 헤더는 홉별(Hop-by-Hop) 헤더(오직 한 개의 전송 링크에만 적용되며, 다음 서버로 전달되서는 안 됨)

  - 4-15b에서 보이는 것처럼, 전달된 HTTP 요청이 서버에 도착하고, 웹 서버가 프록시부터 Connection: Keep-Alive 헤더를 받으면, 웹 서버는 프록시(기존에 클라이언트로부터 받았을 때와 같이)가 커넥션을 유지하자고 요청하는 것으로 잘못 판단하게 됨
  - 4-15c와 같이 웹 서버는 문제 될 것이 없으므로, 프록시와 커넥션을 유지하는 것에 동의를 하고 Connection: Keep-Alive 헤더를 포함하여 응답하며, 웹 서버는 프록시와 keep-alive 커넥션이 맺어진 상태에서 keep-alive 규칙에 맞게 통신하는 것으로 판단하지만, 프록시는 여전히 keep-alive를 전혀 이해하지 못함
  - 4-15b에서 멍청한 프록시는 서버로부터 받은 Conneciton: Keep-Alive 헤더를 포함하고 있는 응답 메세지를 클라이언트에게 전달하며, 클라이언트는 이 헤더를 통해 프록시가 유지하는 것에 동의했다고 추정하며, 이 시점에 클라이언트와 서버는 커넥션을 유지했다고 판단하지만, 프록시는 keep-alive를 이해하지 못함
  - 프록시는 keep-alive를 전혀 모르지만, 받았던 모든 데이터를 그대로 클라이언트에게 전달하고나서 서버가 커넥션을 끊기를 기다리지만, 서버는 프록시가 자신에게 커넥션을 유지하기를 요청한 것으로 알고 있으므로, 커넥션을 끊지 않으며, 따라서, 프록시는 커넥션이 끊어지기 전까지 계속 커넥션이 끊어지기를 기다림
  - 4-15d와 같이 클라이언트가 응답 메세지를 받으면, 다음 요청을 보내기 시작하는데, 커넥션이 유지되고 있는 프록시에 그 요청을 보냄
    + 프록시는 같은 커넥션 상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에, 그 요청은 프록시로부터 무시되고 브라우저는 아무런 응답 없이 로드 중이라는 표시만 나옴
  - 이런 잘못된 통신으로, 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다림

5. 프록시와 홉별 헤더
   - 이런 종류의 잘못된 통신을 피하려면, 프록시는 Connection 헤더와 Conneciton 헤더에 명시된 헤더들은 절대 전달하면 안 됨
   - 따라서, 프록시가 Conneciton: Keep-Alive 헤더를 받으면 Connection 헤더 뿐만 아니라 Keep-Alive란 이름의 헤더도 전달하면 안 됨
   - 또한, Connection 헤더의 값으로 명시되지 않는, Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade와 같은 홉별 헤더들 역시 전달하거나 캐시하면 안 됨
   
