-----
### 사전 인가
-----
1. 일반적인 인증에서는, 각 요청은 트랜잭션이 완료되기 전 요청 / 인증 요구 사이클을 필요로 함
2. 만약 클라이언트가 다음 난스가 무엇이 될 지 미리 알고 있어서, 서버가 물어보기 전 올바른 Authorization 헤더를 생성할 수 있다면, 이 사이클은 생략 가능
3. 만약 클라이언트가 요청을 받기 전 Authorization 헤더를 계산할 수 있다면, 클라이언트는 요청 / 인증 요구 단계를 거치지 않고 미리 Authorization 헤더를 서버에게 제공되며, 성능 개선 효과를 얻을 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/675d2812-3a54-4708-bd81-1397e8268da0">
</div>

4. 사전 인가는 기본 인증에서는 사소하고 흔한 것 : 브라우저는 흔히 사용자 이름과 비밀번호 들에 대한 클라이언트 측 데이버테이스를 관리하며, 사용자가 어떤 사이트에 한 번 인증을 하면, 브라우저는 흔히 그 URL에 대한 다음 번 요청 때 올바른 Authorization 헤더 전송
5. 다이제스트 인증에서의 사전 인가는 복잡함
   - 서버는 임의의 난스를 생성하므로, 인증 요구를 받기 전 클라이언트가 무엇이 올바른 Authorization인지 알 방법이 없음
   - 다이제스트 인증은 여러 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇 가지 방법 제안

6. 클라이언트가 새 WWW-Authenticate 인증 요구를 기다리지 않고 올바른 난스를 취득할 수 있는 방법
   - 서버가 다음 난스를 Authenticateion-Info 성공 헤더에 담아 미리 보냄
   - 서버가 짧은 시간 동안 같은 난스를 재사용하는 것 허용
   - 클라이언트와 서버가 동기화되어 있고, 예측 가능한 난스 생성 알고리즘 사용

7. 다음 난스 미리 생성하기
   - 서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있음
   - 서버는 인증이 성공했을 때, 200 OK 응답과 함께 이 헤더를 보냄
<div align="center">
<img src="https://github.com/user-attachments/assets/532a9ce7-eefb-4486-bfef-1be953004f5c">
</div>

   - 주어진 다음 난스로 클라이언트는 Authorization 헤더를 미리 생성 가능
   - 사전 인가를 통해 요청 / 인증 요구 사이클을 벗어날 수 있지만(트랜잭션 속도 향상), 반면 같은 서버에 다중 요청을 파이프라이닝(Pipelining) 하는 능력은 실질적으로 쓸모가 없어짐
   - 다음 요청을 보내기 전까지 반드시 다음 난스 값을 받아야 하기 때문임
   - 파이프라이닝은 회전 지연(Latency) 회피를 위한 기술이므로, 성능상 불이익은 더 커짐

8. 제한된 난스 재사용
   - 예를 들어, 서버는 한 난스를 다섯 번 혹은 10초간 재사용하도록 허락할 수 있음
   - 이 경우, 클라이언트는 난스를 미리 알 수 있으므로 자유롭게 Authorization 헤더와 함께 요청을 발행하여 파이프라이닝 할 수 있음
   - 난스가 결국 만료되면, 서버는 서버에게 401 Unauthorized 인증 요구를 보낼 것이며, 이 때 WWW-Authenticate: stale=true 지시어는 다음과 같이 설정
<div align="center">
<img src="https://github.com/user-attachments/assets/4a315efc-64f5-4771-a23a-42ca9650705a">
</div>

   - 난스를 재사용하면 공격자 재전송 공격이 성공하기 쉬워지므로 보안성이 감소
   - 난스 재사용 수명은 절대 재사용 안 함 부터 잠재적으로 오랫동안 재사용까지 통제 가능하므로 취약점과 성능 간 트레이드 오프가 있을 수 있음
   - 추가적으로, 카운터 증가나 IP 주소 검사와 같이 재전송 공격을 더 어렵게 만들 수 있는 기능을 채택할 수 있음 (공격을 불편하게 만들 수 있지만 취약은 제거할 수 없음)

9. 동기화된 난스 생성
    - 제3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성 알고리즘 사용하는 것도 가능
   
