-----
### 릴레이
-----
1. HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프록시
2. 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달
3. HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프록시를 구현하는 방식이 유용할 때 존재
   - 데이터를 맹목적으로 전달하도록 구현하기는 쉽기 때문에, 단순 필터링이나 진단 혹은 콘텐츠 변환을 하는데 사용되기도 함
   - 하지만, 이는 잠재적으로 심각한 상호 운용 문제를 가지고 있기 때문에 주의해서 배포해야 함

4. 단순 맹목적 릴레이를 구현하는데 관련된 더 일반적인 문제는 맹목적 릴레이 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행(Hang)에 걸리는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/1e812e74-2ce2-4090-8693-66570fea5a7e">
</div>

   - 8-14a : 웹 클라이언트는 Conneciton: Keep-Alive 헤더를 보내서, 릴레이에 keep-alive 커넥션을 맺기를 원한다는 내용의 요청 메세지 전송
     + 클라이언트는 keep-alive 채너러에 대한 요청이 받아들여졌는지 확인하기 위해 응답을 기다림

   - 8-14b : 릴레이가 HTTP 요청을 받지만, Connection 헤더를 이해하지 못하므로, 단순히 요청을 서버로 넘김
     + 하지만 Connection 헤더는 홉과 홉 사이에만 사용하는 헤더로서, 이는 단일 전송 링크만을 지원하고 체인을 따라 전달할 수 없음
   
   - 릴레이 된 HTTP 요청이 웹 서버에 도착하며, 웹 서버가 프록시로부터 Connection: Keep-Alive 헤더를 받으면, 릴레이가 keep-alive를 하기 바란다고(보통 클라이언트가 서버에게 하는 것처럼) 잘못된 결론을 내려버림
     + 웹 서버는 문제가 없다고 생각하며, 웹 서버는 8-14c와 같이 keep-alive로 통신하는 것에 동의하고 Connection: Keep-Alive 응답 헤더로 응답
     + 이 시점부터, 웹 서버는 릴레이와 함꼐 keep-alive 통신을 하고, keep-alive의 규칙에 맞게 동작할 것이지만, 릴레이는 이에 대해 아무것도 모름

   - 8-14d에서 릴레이는 웹 서버로부터 받은 Connection: Keep-Alive 헤더를 포함한 응답 메세지를 클라이언트에게 전달
     + 클라이언트는 이 헤더를 통해 릴레이가 keep-alive로 통신하는 것에 동의했다고 추측
     + 이 시점에 클라이언트와 서버는 keep-alive로 통신하고 있다고 믿고 있지만, 그들이 실제로 통신하는 릴레이는 keep-alive가 무엇인지 모름

   - 릴레이는 keep-alive에 대해 아무것도 모르므로, 원 서버가 커넥션을 끊기를 기다리며 받은 데이터 전부를 그대로 클라이언트에게 전달
     + 하지만 원 서버는 릴레이가 자신에게 커넥션을 계속 맺고 있기를 요청했다고 믿기 때문에, 커넥션을 끊지 않을 것
     + 따라서, 릴레이는 커넥션이 끊길 때를 기다리며 계속 커넥션을 맺고(Hang) 있을 것

   - 8-14d와 같이 클라이언트가 응답 메세지를 받으면, 바로 다음 요청을 keep-alive 커넥션을 통해 릴레이에게 전송(8-14e)
     + 단순한 릴레이는 같으 커넥션으로 또 다른 요청이 오는 것을 예측하지 못함
     + 브라우저는 계속 돌고 있지만, 아무런 작업도 진행되지 않음

5. 만약 특정 목적을 위해 단순한 HTTP 릴레이를 구축하는 중이라면, 이를 어떻게 사용할지 신중히 고민 필요
6. 또한, 여러 문제를 예방하기 위해 HTTP를 제대로 준수하는 프록시를 사용하는 것이 좋음
