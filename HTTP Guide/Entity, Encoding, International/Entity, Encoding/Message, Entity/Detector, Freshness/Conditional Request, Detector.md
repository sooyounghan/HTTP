-----
### 조건부 요청과 검사기
-----
1. 캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면, 캐시는 자신이 갖고 있는 사본을 신선한 것으로 만들 필요가 있음
2. 캐시는 원 서버에서 현 시점의 사본을 가져올 수 있지만, 대개 서버에 있는 문서는 여전히 캐시에 들어있는 신선하지 못한 사본과 같를 것
3. 캐시된 사본은 만료될 수 있지만, 서버 콘텐츠는 여전히 콘텐츠와 같음
   - 만약 서버의 문서가 캐시가 갖고 있는 것과 같음에도 불구하고 항상 그 문서를 가져온다면, 캐시는 네트워크의 대역폭을 낭비하고, 캐시와 서버에 불필요한 부하를 주고, 모든 것을 느려지게 만들 수 있음

4. 이를 고치기 위해 HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라는 특별한 요청 방법을 제공
   - 조건부 요청은 평범한 HTTP 요청 메세지이지만, 특정 조건이 참일 때만 수행
   - 예를 들어, 캐시는 다음의 조건부 GET 메세지를 보내서, /announce.html 파일이 2002년 6월 29일(캐시된 문서가 작성자에 의해 마지막으로 변경된 날짜) 이후 변경된 경우에만 한해서 파일을 보내달라고 할 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/cb554032-240a-4000-875b-d93b1b92bf11">
</div>

   - 조건부 요청은 If-로 시작하는 조건부 헤더에 의해 구현되며, 위 예에서 조건부 헤더는 If-Modified-Since
   - 조건부 헤더는 조건이 참일 때만 수행되도록 하며, 만약 조건이 참이 아니면 서버는 HTTP 에러 코드를 돌려보냄

5. 각 조건부 요청은 특정 검사기 위에서만 동작 : 검사기는 문서의 테스트된 특정 속성
6. If-Modified-Since 상태 헤더는 문서 인스턴스의 마지막 수정된 날짜를 검사하므로, 마지막 수정된 날짜를 검사기라고 말할 수 있음
7. If-None-Match 조건부 헤더는 문서의 ETag 값을 평가
   - ETag는 특별한 키워드이거나 엔티티와 관련된 버전 식별 태그
8. Last-Modified와 ETag는 HTTP에 의해 사용되는 두 개의 중요 검사기
9. 조건부 요청을 위해 사용되는 4가지 헤더 : 각 조건부 헤더 다음 있는 것은 그 헤더에 의해 사용되는 검사기 유형
<div align="center">
<img src="https://github.com/user-attachments/assets/df736fdf-41e2-44f3-bdbb-be928b224c94">
</div>

10. HTTP는 검사기를 약한 검사기와 강한 검사기의 두 가지로 분류
    - 약한 검사기는 리소스의 인스턴스를 고유하게 식별하지(Uniquely Identify) 못하는 경우도 존재
    - 강한 검사기는 언제나 고유하게 식별
    - 약한 검사기의 예 : 객체의 바이트 단위 크기가 있으며, 리소스 콘텐츠는 크기가 같더라도 내용이 다를 수 있으므로, 바이트 개수를 세는 방식으로 동작하는 가상 횟수 검사기는 변경이 발생했음을 약하게만 감지 가능
    - 그러나 리소스 콘텐츠에 대한 암호 체크섬(MD5와 같은)은 강한 검사기로, 이는 문서가 변경되면 함께 변경

11. 최종 변경 시각은 리소스가 마지막으로 수정된 시각을 의미함에도 불구하고, 약한 검사기로 간주되는데, 정확도가 최대 1초에 불과함
    - 리소스는 1초에 여러 번 변경될 수 있고, 서버는 1초에 수천 번 요청을 처리하므로, 최종 변경 시각은 변경이 발생했음을 항상 반영해주지 못함
    - ETag 헤더는 강한 검사기로 간주되는데, 서버는 ETag 헤더에 매 변경마다 구분되는 값을 넣어두기 때문임
    - 버전 번호와 요약 체크섬은 ETag 헤더의 좋은 후보이지만, 그 외의 어떤 텍스트도 포함할 수 있으며, 유연하고 어떤 텍스트 값도 가질 수 있고(tags) 클라이언트와 서버의 다양한 검사를 창안하기 위해 사용될 수 있음

12. 클라이언트와 서버는 때때로 엔티티 태그 검사를 통과하지 못한 버전을 채택하는 경우 존재
    - 예를 들어, 서버는 크고 자주 찾는 캐시된 문서에 대해, 캐시의 재검사로 인한 대량 전송을 유발하지 않으면서 겉모양새만 변경하고 싶을 수 있는데, 서버는 태그 앞에 W/를 붙임으로써 약한 엔티티 태그임을 알림
    - 약한 엔티티 태그는 엔티티 의미 상 두드러진 변화에만 사용할 수 있으며, 강한 엔티티 태그는 관련된 엔티티 값이 아무리 사소하게 바뀌었더라도 함께 변경되어야 함

13. 클라이언트가 약한 엔티티 태그를 사용해서 서버와 재검사를 하는지 보여줌
    - 서버는 콘텐츠가 문서 버전 4.0 이후 의미있는 변경이 있었을 때만 본문을 반환
<div align="center">
<img src="https://github.com/user-attachments/assets/25e07bf8-5f77-4226-b302-c10e1eb32d10">
</div>

   - 요약하면, 클라이언트가 같은 리소스를 한 번 이상 접근했을 때, 우선 현재 사본이 여전히 신선한지 판별
   - 만약 그렇지 않다면, 클라이언트는 반드시 서버로부터 최신 버전을 얻어와야 함
   - 리소스가 변경되지 않은 상황에서 똑같은 사본을 다시 받아오는 상황을 피하기 위해, 클라이언트는 서버에 현재 사본을 유일하게 식별할 수 있는 검사기를 명시해 조건부 요청을 보낼 수 있음
   - 서버는 오직 클라이언트 사본과 다를 때만 리소스 사본을 보낼 것
