-----
### 다이제스트 인증의 개선점
-----
1. 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 다른 HTTP 인증 프로토콜
2. 특징
   - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않음
   - 인증 체결을 가로채 재현하려는 악의적 사람들을 차단
   - 구현하기에 따라 메세지 내용 위조를 막는 것도 가능
   - 잘 알려진 형태의 공격을 막음

3. 다이제스트 인증이 가능한 가장 안전한 프로토콜은 아님
   - 예를 들어, 공개키 기반 메커니즘과 비교할 때, 다이제스트 인증은 그다지 강력한 인증 메커니즘을 제공하지 않으며, 비밀번호 자체를 보호하는 것을 넘어서는 어떠한 비밀 번호도 제공하지 않음 (즉, 요청과 응답 나머지 부분에 대해서 다른 누군가가 엿보는 것 가능)
   - 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 못하며, 그러한 요구사항에는 전송 계층 보안(TLS)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜
   - 그러나, 기본 인증보다 훨씬 강력하며, 다른 인터넷 서비스를 위해 제한된 많은 인기 있는 보안 체계들(예) LDAP, POP, IMAP을 위해 제안된 CRAM-MD5)보다 더 강력

4. 아직까지 널리 쓰이지는 않고 있지만, 기본 인증이 내재된 보안 위험 때문에, HTTP 설계자들은 '기본 인증을 사용하는 오늘날 모든 서비스는 가능한 한 다이제스트 인증으로 전환해야한다.'라고 조언

-----
### 다이제스트 인증 동작 과정
-----
1. 다이제스트는 비밀번호 대신, 클라이언트는 비밀번호를 비가역적으로 뒤섞은 지문(Fingerprint) 혹은 요약(Digest)를 보냄
   - 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있음

2. 동작 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/499c91f5-8b7c-42d1-94e1-c5e65d476b92">
</div>

   - 13-1a : 클라이언트가 보호된 문서 요구
   - 13-1b : 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서 제공하는 것을 거부
     + 서버는 클라이언트에게 사용자 이름과 요약된 형태 비밀번호 요구
   - 13-1c : 클라이언트는 비밀번호 요약을 전달하여 자신이 비밀번호를 알고 있음을 증명
     + 서버는 모든 사용자의 비밀번호를 알고 있으므로(서버는 비밀번호의 다이제스트(요약)만을 알고 있으면 됨), 클라이언트가 제공한 요약과 서버가 스스로 계산한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인 가능
     + 비밀번호를 모르는 올바른 요약을 만들어내기 쉽지 않음
   - 13-1d : 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약 비교
     + 일치하면, 이는 클라이언트가 비밀번호를 알고 있는 것
     + 이 요약 함수는 매우 긴 자릿수의 숫자를 만들어낼 수 있으므로 사실상 찍어서 맞추는 것은 불가능
     + 서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공
     + 이 모든 과정에서 비밀 번호는 결코 네트워크를 통해 전송되지 않음
