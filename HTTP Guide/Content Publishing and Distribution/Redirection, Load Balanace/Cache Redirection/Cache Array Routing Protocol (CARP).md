-----
### 캐시 배열 라우팅 프로토콜 (Cache Array Routing Protocol, CARP)
-----
1. 프록시 서버는 사용자 개개인으로부터 요청을 가로채어 요청한 웹 객체의 캐시된 사본을 제공함으로써 향하는 트래픽을 대폭 줄여줌
   - 그러나 사용자의 증가에 따라, 대량의 트래픽은 프록시 서버 자체에 과도한 부하를 줄 수 있음

2. 이 문제에 대한 해결책 중 하나는 부하 분산을 위해 사용하는 프록시 서버를 여러 대로 늘리는 것
   - 캐시 배열 라우팅 프로토콜(CARP)은, 프록시 서버의 배열이 클라이언트의 시점에서는 마치 하나의 논리적 캐시처럼 보이도록 관리해주는 마이크로소프트와 넷스케이프 커뮤니케이션에서 제안한 표준
  
3. ICP의 대안으로, CARP와 ICP 둘 다 관리자가 여러 대의 프록시 서버를 사용하여 성능을 개선할 수 있게 해줌
4. ICP에서 캐시 비적중이 발생하면, 프록시 서버는 웹 객체의 가용성을 판단하기 위해 이웃 캐시들에게 ICP 메세지 포맷을 사용해 질의를 보냄
   - 이웃의 캐시들은 HIT이나 MISS로 응답하고, 요청한 프록시 서버는 이 응답을 이용해 객체를 받아올 가장 적절한 위치를 선택
   - 만약 ICP 프록시 서버들이 계층적으로 구성되었다면, 비적중은 부모에게 상향 전파

5. ICP로 적중과 비적중이 결정되는 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/f69fbb40-3741-4e5d-bbde-f4fd0e46c5cb">
</div>

  - ICP 프로토콜로 서로 연결된 프록시 서버들 각각은 컨텐츠의 쓸데없는 복제본도 갖고 있는, 다시 말해 프록시 서버들 전체에 걸친 웹 객체에 대한 중복된 엔트리가 허용되는 독립적 캐시임
  - 대조적으로 CARP를 이용해 독자적으로 동작하는 서버들의 무리는, 각 구성요소 서버가 전체 캐시된 문서의 일부만 갖고 있는 하나의 큰 서버처럼 동작
  - 웹 객체의 URL에 해시 함수를 적용함으로써, CARP는 웹 객체를 특정 프록시 서버에 매핑
  - 하나의 웹 객체는 하나의 프록시 서버에만 속하므로, 프록시 서버 각각을 폴링하지 않고도 한 번의 검색으로 그 객체의 위치 결정 가능

6. CARP 접근 방법
<div align="center">
<img src="https://github.com/user-attachments/assets/ca11d5b2-f7f3-4743-b784-ec79639510d9">
</div>

   - 클라이언트와 프록시 서버 사이의 중개자로서 부하를 여러 프록시 서버로 분산하는 캐싱 프록시를 보여주고 있지만, 클라이언트들 스스로 이 기능을 제공하는 것도 가능
   - 인터넷 익스프롤러나 크롬 같은 상업적 브라우저는 어떤 요청이 보내져야 하는지 결정하기 위한 해시 함수를 계산하는 플러그인 설정 가능

7. CARP에서 프록시 서버 분석이 결정론적(Deterministic)이라는 것은 질의를 모든 이웃에게 보낼 필요는 없다는 뜻이며, 이는 캐시가 주고 받아야 하는 메세지가 더 적음을 의미
   - 더 많은 프록시 서버가 설정에 추가됨에 따라, 그 집단 캐시 시스템은 괜찮게 확장
   - 그러나 CARP은 프록시 서버 중 하나가 사용할 수 없게 되면, 이 사실을 반영하기 위해 함수가 수정되어야 하고, 프록시 서버 전체에 퍼져 있는 콘텐츠들도 다시 배치하지 않을 수 없다는 단점 존재
   - 프록시 서버의 고장이 잦다면 이로 인한 비용은 상당히 비쌀수 있음

8. 반면 ICP 프록시 서버들에는 콘텐츠가 중복되어 존재하므로, 다시 배치할 필요가 없으며, 또 하나의 잠재적 문제점은 CARP는 새로운 프로토콜이므로 ICP 프로토콜만을 수행하는 기존 프록시 서버는 CARP 무리에 쉽게 포함될 수 없을 것이라는 점
9. CARP의 리다이렉션 방법
    - 참여하는 프록시 서버 테이블을 유지 : 이 프록시 서버들은 각각이 살아 있는지 알아보기 위해 주기적 폴링
    - 각 참여 프록시 서버들에 대해 해시 함수 계산 : 해시 함수가 반환하는 값은 이 프록시가 처리할 수 있는 부하의 양을 계산에 넣음
    - 요청한 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시 함수 정의
    - URL의 해시 함수와 프록시 서버 해시 함수의 합계로 값의 배열을 얻음 : 이 값들에 대한 최댓값이 그 URL을 위해 사용할 프록시 서버 결정
      + 계산값이 결정적이므로, 같은 웹 객체에 대한 뒤이은 요청은 같은 프록시 서버로 포워딩될 것

     - 이 네 개의 작업은 플로그인을 통해 브라우저에 의해 수행될 수도 있고, 중간 서버에 의해 계산될 수 있음

10. 프록시 서버들의 각 무리는 그 무리의 모든 서버를 나열하는 테이블 생성
    - 테이블의 각 엔트리는 부하 인자에 대한 정보, 생존시간(Time-To-Live, TTL) 카운트다운 값, 구성원들이 얼마나 자주 폴링되어야 하는지에 등에 대한 전역 매개변수를 포함
    - 부하 인자는 장비가 얼마나 큰 부하를 다룰 수 있는지(CPU 속도와 하드드라이브 용량에 의해 결정될 것) 명시
    - 그 테이블은 RPC 인터페이스를 통해 원격으로 관리될 수 있고, 테이블의 필드들이 RPC에 의해 갱신되면, 그 필드들은 사용할 수 있게 되거나 혹은 다운스트림의 클라이언트들에게 배포됨
    - 이 배포는 HTTP에 의해 수행되므로 어떤 클라이언트나 프록시 서버도 다른 프록시 프로토콜을 도입할 필요 없이 그 테이블의 정보를 사용할 수 있음
    - 클라이언트와 프록시 서버는 테이블을 가져오기 위해 단순히 잘 알려진 URL 사용

11. 이 사용된 해시 함수는 웹 객체가 참여하는 프록시 서버들 전체에 걸쳐 정적으로 분산되었음을 반드시 보장해야 함
    - 프록시 서버의 부하 인자는 그 프록시에 할다된 웹 객체으 통계적 확률을 결정하기 위해 사용되어야 함

12. 요약
     - CARP 프로토콜은 협력은 하지만, 분산된 캐시가 되는 ICP와 달리 프록시 서버 그룹을 하나의 캐시 집단으로 보이게 함
     - 결정론적 요청 분석 경로로는 한 홉 안에 있는 특정 웹 객체의 거처를 찾아내며, 이는 ICP에서 프록시 서버 그룹 안에 있는 웹 객체를 찾아내기 위해 자주 생성되는 프록시 간 트래픽을 제거
     - CARP는 또한 중복된 웹 캐시에 대한 사본의 중복을 피하게 되는데, 이로 인해 캐시 시스템이 집합적으로 웹 객체를 더 많이 보관할 수 있다는 장점 존재
     - 어느 하나의 프록시가 실패하더라도 상당량의 캐시 콘텐츠를 재배치해야 한다는 단점
