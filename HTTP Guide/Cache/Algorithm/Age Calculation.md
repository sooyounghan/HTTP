-----
### 나이 계산
-----
1. 응답의 나이는 응답이 서버에서 생성되었을(혹은 서버로부터 재검사되었을) 떄부터 지금까지의 총 시간
2. 그 나이는 응답이 인터넷 상의 라우터들과 게이트웨이들 사이를 떠돌아다닌 시간(중개 캐시에 기록)과 응답이 캐시에 머물렀던 시간 포함
<div align="center">
<img src="https://github.com/user-attachments/assets/4ecaec5a-eb9c-4f97-93f3-5b9da45d83b8">
</div>

3. HTTP 나이 게산의 세부는 까다롭지만 기본 개념은 단순
   - 캐시는 응답이 캐시에 도착했을 때 Date나 Age 헤더를 분석해서 얼마나 오래된 것인지 알 수 있음
   - 캐시는 또한 그 문서가 로컬 캐시에 얼마나 오래 머물렀는지 알 수 있음
   - 이 둘을 합하면, 이 값들은 응답 전체 나이가 되며, HTTP는 클록 스큐(Clock Skew)와 네트워크 지연을 보상을 위한 방안 사용
   - 기본 계산은 다음과 같음
<div align="center">
<img src="https://github.com/user-attachments/assets/150d0f0e-a9b7-4472-864b-fcd39f705eb1">
</div>

4. 캐시는 캐시된 사본이 로컬에서 얼마나 오랫동안 캐시되었는지 아주 쉽게 알아낼 수 있음
5. 그러나 캐시에서 온 응답의 나이를 알아내는 것은 어려운데, 모든 서버가 동기화된 시계를 갖고 있지 않으며 응답이 어디에서 왔는지 모르기 때문임
6. 완전한 나이 계산 알고리즘은 이를 바로잡으려 시도

-----
### 겉보기 나이는 Date 헤더에 기반
-----
1. 만약 모든 컴퓨터가 똑같이 정확한 시계를 갖고 있다면, 캐시된 문서의 나이는, 단순히 현재 시간에서 서버가 문서를 보낸 시간을 뺀, 문서의 겉보기 나이가 될 것
2. 서버는 시간은 단순히 Date 헤더 값으로 보내며, 가장 단순한 기초적 나이 계산은 그냥 겉보기 나이를 사용하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/7c3268f0-355c-42c6-92bc-465e8848fe03">
</div>

3. 불행히도, 모든 시계가 잘 동기화되진 않으며, 클라이언트와 서버 시계는 몇 분 정도 서로 차이가 있을 수 있으며, 심지어 몇 시간이나 며칠이 다를 수 있음 (따라서, HTTP 명세는 클라이언트 / 서버 / 프록시가 서로 동일한 시간축을 갖도록 NTP와 같은 시간 동기화 프로토콜을 사용할 것 권장)
4. 웹 애플리케이션, 특히 캐시 프록시는 시계 값이 극단적으로 차이 나는 서버와 상호작용 하는 경우 대비해야 함
   - 이와 같은 두 컴퓨터의 시계 설정으로 인한 문제를 클록 스큐(Clock Skew)라고 부름
   - 클록 스큐 때문에, 겉보기 나이는 종종 부정확하며 때로는 음수가 되기도 함

5. 만약, 나이가 음수가 되는 일이 있다면, 다음의 펄 의사코드와 같이 바로 0으로 만들어야 함
   - 또한 겉보기 나이가 터무니없이 커지지 않도록 간단한 검사를 추가할 수 있지만, 큰 겉보기 나이가 사실은 맞는 값일 수 있음
   - 오랫동안 문서를 캐시하고 있는(원래 Date 헤더를 보관하고 있는) 부모 캐시와 대화중일 수 있기 때문임
<div align="center">
<img src="https://github.com/user-attachments/assets/03041e76-94b2-4abd-a110-af21aaeb5b38">
</div>

   - Date 헤더는 원래 원 서버 날짜를 서술한다는 사실에 주의 (프록시와 캐시는 이 날짜를 절대 변경하면 안 됨)

-----
### 점층적 나이 계산
-----
1. 클록 스큐를 초래하는 음수 나이를 제거할 수 있지만, 클록 스큐로 인한 정확도 손실 전반에 대해서는 별로 할 수 있는 일이 없음
2. HTTP/1.1은 동기화 된 시계라는 것이 존재하지 않는 문제에 대한 우회책으로, 문서나 프록시나 캐시를 통과할 때 마다 그 장치들이 Age 헤더에 상대적 나이를 누적해 더하도록 함
   - 이 방법은 서버 간 시간 비교나 종단 간 시간 비교를 필요로 하지 않음

3. Age 헤더 값은 문서가 프록시들을 통과하면서 점점 늘어남
   - HTTP/1.1를 이해하는 애플리케이션은 문서가 각 애플리케이션에 머무른 시간과 네트워크 사이를 이동한 시간만큼 Age 헤더 값을 늘려야 함
   - 각 중간 애플리케이션은 자신의 내부 시계를 이용해 쉽게 문서의 체류 시간을 계산할 수 있음
  
4. 그러나 응답 체인에 있는 비-HTTP/1.1 장치는 Age 헤더를 인식하지 못하고 그 헤더를 고치지 않거나 삭제해 버림
   - 즉, HTTP/1.1을 채택하기 전까지, Age 헤더는 상대 나이에 대한 모자란 추정값인 상태로 존재

5. 이 상대 나이 값은 Date 기반 나이와 별개로 계산되어, 두 나이 추정값 중 보수적인(가장 큰) 것이 선택
   - 다른 서버에서 넘어온 Date 값이나 나이 계산값은 실제보다 작게 계산된 값일 수 있기 때문임
   - HTTP는 더 신선한 콘텐츠를 얻을 수 있다면 Age 헤더의 오류도 용인
<div align="center">
<img src="https://github.com/user-attachments/assets/9f89d4ef-9453-4526-87b5-2443f415fde1">
</div>

-----
### 네트워크 지연에 대한 보상
-----
1. 트랜잭션은 느려질 수 있으므로, 캐시를 하는 주요 동기
2. 그러나 매우 느린 네트워크나 과부하가 걸린 서버에서, 문서가 네트워크나 서버의 교통 혼잡에 긴 시간 동안 갇혀있었던 경우 상대 나이 계산은 문서의 나이에 대한 상당히 모자란 추정이 될 수 있음
3. Date 헤더는 언제 문서가 원 서버를 떠났는지 나타내지만, 문서가 캐시로 옮겨가는 도중 얼마나 시간을 소비했는지 말해주지 않음
4. 만약, 문서가 프록시들과 부모 캐시의 긴 연쇄를 거쳐 왔다면 네트워크 지연은 상당한 수준
5. 서버에서 캐시로의 단방향 네트워크 지연을 측정하는 쉬운 방법은 없지만, 왕복 지연을 계산하는 것은 상대적으로 쉬움
   - 캐시는 언제 문서를 요청했고, 언제도착했는지 알고 있음
   - HTTP/1.1은 이를 이용해 게싼한 전체 왕복 시간을 더함으로써 네트워크 지연을 보수적으로 교정
   - 캐시에서 서버로 갔다가 다시 캐시로 돌아오느라 발생한 지연은, 서버에서 캐시로 가느라 발생한 지연을 보수적으로 크게 추정한 것
   - 만약 오차가 있다면, 문서를 실제보다 오래되어 보이게 만들어서 불필요한 재검사를 하게만들 것
<div align="center">
<img src="https://github.com/user-attachments/assets/88664d7d-377f-419e-9383-21eb37c996f7">
</div>
