-----
### 프락시 요청 특징
-----
1. 프락시 URI는 서버 URI과 다름
   - 웹 서버와 웹 프록시 메세지 문법은 서로 같지만, 한 가지 예외 존재 : 클라이언트가 프록시 대신 서버로 요청을 보내면 요청의 URI가 달라짐
   - 클라이언트가 웹 서버로 요청을 보낼 때, 요청줄은 다음과 같이 스킴, 호스트, 포트번호가 없는 부분 URI를 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/4b8d10da-0b22-479a-9e91-2390a6e58579">
</div>

2. 그러나 클라이언트로 프록시로 요청을 보낼 때, 요청줄은 다음의 예와 같이 완전한 URI를 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/093da9e8-041f-43cf-af4e-8006b35b4a87">
</div>

3. 다른 요청 형식을 갖는 이유
   - 원래의 HTTP 설계에서, 클라이언트는 단일 서버와 직접 대화했음
   - 가상 호스팅은 아직 존재하지 않았고, 프록시에 대한 대비도 없었음
   - 단일 서버는 자신의 호스트 명과 포트번호를 알고 있으므로, 클라이언트는 불필요한 정보 발송을 피하기 위해 스킴과 호스트(그리고 포트번호)가 없는 부분 URI만 보냈음
   - 프록시가 부상하면서, 부분 URI는 문제가 되었음
     + 프록시는 목적지 서버와 커넥션을 맺어야 하므로, 그 서버의 이름을 알 필요가 있음
     + 그리고 프록시 기반 게이트웨이는 FTP 리소스나 혹은 그 외의 스킴과 연결하기 위해 URI 스킴을 알 필요가 있었음
     + HTTP/1.0은 프록시 요청의 경우 완전한 URI를 요구하는 것으로 이 문제를 해결했지만, 서버 요청 부분 URI은 여전히 문제 (모두 완전한 URI로 전환하기에 너무 많은 서버가 배치)
     + 따라서 프락시와 서버 요청 모두에 대해 HTTP/1.1은 현재 서버들이 완전한 URI를 다룰 것을 요구하지만, 현실에는 배치 되어 있는 서버들 중 다수가 여전히 부분 URI만을 받아들임

   - 따라서, 서버로는 부분 URI를, 프록시로는 완전한 URI를 보낼 필요가 있으며, 명시적으로 설정된 클라이언트 프록시 설정의 경우, 클라이언트는 어떻게 요청을 보내야 하는지 알고 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/3953e66a-7832-4c51-89ad-0cdfcdd7036e">
</div>

   - 클라이언트가 프록시를 사용하지 않도록 설정되었다면, 부분 URI를 보냄 (6-15a)
   - 클라이언트가 프록시를 사용하도록 설정되었다면, 완전한 URI를 보냄 (6-15b)

4. 가상 호스팅에서 일어나는 같은 문제
   - 프록시의 스킴/호스트/포트번호 누락 문제는 가상으로 호스팅되는 웹 서버가 직면한 것과 같은 문제
   - 가상으로 호스팅되는 웹 서버는 여러 웹 사이트가 같은 물리적 웹 서버를 공유
   - 요청 하나가 부분 URI /index.html로 오면, 가상으로 호스팅 되는 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 있음
   - 해결 방법
     + 명시적인 프록시는 요청 메세지가 완전한 URI를 갖도록 문제 해결
     + 가상으로 호스팅 되는 웹 서버는 호스트와 포트에 대한 정보가 담겨있는 Host 헤더 요구

5. 인터셉트 프록시는 부분 URI를 받음
   - 클라이언트가 HTTP를 올바르게 구현했다면, 그들은 명시적으로 설정된 프록시에게는 완전한 URI를 보낼 것
   - 문제의 일부분은 해결되지만, 클라이언트는 자신이 프록시와 대화하고 있음을 항상 알고 있지 않음
     + 왜냐하면 몇 프록시는 클라이언트에게는 보이지 않을 수 있기 때문임
     + 비록, 클라이언트가 프록시를 사용한다고 설정되어 있지 않더라도, 클라이언트 트래픽은 여전히 대리 프록시나 인터셉트 프록시를 지날 수 있음
     + 두 가지 경우 모두, 클라이언트는 자신의 웹 서버와 대화하고 있다고 생각하고 완전한 URI를 보내지 않을 것

    - 대리 프록시는 원 서버와 호스트 명과 아이피 주소를 원 서버를 대신하는 프록시 서버
    - 인터셉트 프록시는 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽은 가로채 캐시된 응답을 돌려주는 등의 일을 하는 프록시 서버로, 클라이언트에서 서버로 가는 트래픽을 가로채기 때문에, 웹 서버로 보내는 부분 URI를 얻게 될 것 (인터셉트 프록시는 보통 80번 포트만 가로챔)

6. 프록시는 프록시 요청과 서버 요청 모두 다룰 수 있음
   - 트래픽이 프록시 서버로 리다이렉트 될 수 있는 여러 가지 방법 존재
   - 다목적 프록시 서버는 요청 메시지의 완전한 URI 부분과 부분 URI를 모두 지원해야 함
   - 프록시는 명시적인 프록시 요청에 대해서는 완전한 URI를 사용하고 아니면 부분 URI를 사용해야 하며, 웹 서버 요청의 경우에는 가상 Host 헤더를 사용
   - 완전 URI과 부분 URI를 사용하는 규칙
     + 완전한 URI가 주어진다면, 프록시는 이를 사용해야 함
     + 부분 URI가 주어졌고, Host 헤더가 있다면, Host 헤더를 이용해 원 서버 이름과 포트 번호를 알아내야함
     + 부분 URI이 주어졌으나, Host 헤더가 없다면, 다음 방법으로 원 서버를 알아냄
       * 프록시가 원 서버를 대신하는 대리 프록시라면, 프록시에 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있음
       * 이전에 어떤 인터셉트 프록시가 가로챘던 트래픽을 받았고, 그 인터셉트 프록시가 원 IP 주소와 포트번호를 사용할 수 있도록 해뒀다면, 그 IP 주소와 포트 번호를 사용할 수 있음
       * 모두 실패했다면, 프록시는 원 서버를 알아낼 수 있는 충분한 정보를 갖지 못한 것이므로 반드시 에러 메세지(보통 사용자에게 Host 헤더를 지원하는 현대적 웹브라우저로 업그레이드)를 반환

7. 전송 중 URI 변경
   - 프록시 서버는 요청 URI 변경에 매우 신경을 써야함
   - 무해해 보이는 사소한 URI 변경이더라도 다운 스트림 서버와 상호 운용성 문제 발생 가능
   - 특히 몇몇 프록시는 URI를 다음 홉으로 보내기 전 표준 형식으로 정규화하는 것으로 알려져 있음
     + URI에서 기본 HTTP 포트를 명시적인 :80으로 변경하는 것이나 잘못 사용한 예약된 글자를 올바르게 이스케이프하여 교체하는 것과 같은 무해해 보이는 변형이라 할지라도, 상호운용성 문제를 일으킬 수 있음
   - 일반적으로 프록시 서버는 가능한 한 관대하도록 애써야 함
   - HTTP 명세는 일반적인 인터셉트 프록시가 URI를 전달할 때, 절대 경로를 고쳐 쓰는 것을 금지하며, 유일한 예외는 빈 경로를 '/'로 교체하는 것

8. URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)
   - 브라우저는 프록시 존재 여부에 따라 요청 URI를 다르게 분석
   - 프록시가 없다면 사용자가 타이핑한 URI를 가지고 그에 대응하는 IP 주소를 찾음
   - 만약 호스트 명이 발견되면 그에 대응하는 IP 주소들을 연결에 성공할 때까지 시도
   - 그러나 호스트가 발견되지 않는다면, 많은 브라우저들은 사용자가 호스트 명의 짧은 약어를 타이핑 한 것으로 보고 자동화된 호스트 명의 확장을 제공하고자 다음과 같은 몇 가지 시도 실시
     + 일반적인 웹 사이트 이름의 가운데 부분만 입력했다면, 많은 브라우저는 ```www.``` 접두사를 붙이고, ```.com``` 접미사를 붙임
     + 몇몇 브라우저는 해석할 수 없는 URI를 서드파티 사이트로 넘기도록 하는데, 이 사이트는 오타 교정을 시도하고 사용자가 의도했을 URI 제시
     + 대부분의 시스템에서 DNS는 사용자가 호스트 명 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정
       * 예를 들어, ```oreilly.com```이라는 도메인에 있을 때, host7을 입력한다면, 그 도메인의 DNS는 자동으로 ```host.oreilly.com```을 찾아봄 (이는 완전하지도, 유효하지도 않은 호스트명)
