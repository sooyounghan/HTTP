-----
### 지속 커넥션의 제한과 규칙
-----
1. 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈다면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음
2. 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 함
3. 커넥션에 있는 모든 메세지가 자신의 길이 정보를 정확히 가지고 있을 때에만, 커넥션을 지속시킬 수 있음
   - 예를 들어, 엔티티 본문은 정확한 Content-Length의 값을 가지거나 청크 전송 인코딩(Chunked Transfer Encoding)으로 인코드 되어 있어야 함

4. HTTP/1.1 프록시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리
5. HTTP/1.1 프록시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안 됨
   - 오래된 프록시가 Connection 헤더를 전달하는 문제가 발생할 수 있음 (현실적으로 지켜지지 않음)

6. 서버는 메세지를 전송하는 중간에 커넥션을 끊지 않을 것이고, 커넥션을 끊기 전에 적어도 한 개의 요청에 대해 응답을 할 것이지만, HTTP/ 1.1 기기는 Connection 헤더 값과는 상관없이 언제든지 커넥션을 끊을 수 있음
7. HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 하며, 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 다시 보내야 함
8. 클라이언트는 전체 응답을 받기 전 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어 있어야 함
9. 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 두 개의 지속 커넥션을 유지해야 하며, 따라서 N명의 사용자가 서버로 접근한다면, 프록시는 서버나 상위 프록시에 넉넉잡아 약 2N개의 커넥션을 유지해야 함
